# 类型双关

**定义**：指绕开语言的**类型系统**，直接将一种类型的**内存**当成**另一种类型**对待

**实现**：

e.g. `int`类型内存直接双关为`double`类型.

```cpp
/*前置小知识*/
//int类型单数据占1B
//double类型单数据占2B
//char类型单数据占1b
int a = 33;
double b = *(double*)&a;
//&a 指取a的地址(整形指针),
//(double*)&a 指把指向a地址的整形指针像强制转为双浮点指针,
//*(double*)&a 指取以上的双浮点指针逆引用
std::cout << "a = " << a << std::endl;//检查a
std::cout << "b = " << b << std::endl;//检查b
std::cin.get();//此处F9添加断点
```

输出：

```
a = 9
b = 2.55267e-76
```

调试查看内存：

```
&a
0x00000021F258F8E4  09 00 00 00 d3 8e 3d 30 fd 7f 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ....??=0?.....................

&b
0x00000021F258F908  09 00 00 00 d3 8e 3d 30 1a 75 03 3a 7d a3 00 00 50 98 4d d0 fd 7f 00 00 0a 75 03 3a 7d a3  ....??=0.u.:}?..P?M??....u.:}?
```

可以看到`b`是直接把`a`的**`1B`**内存给拷贝过来了，

但是`double`类型读取内存读的是**`2B`**，

况且`double`类型的**读取方式**也不一样 (IOI-tormentee, u must've known it~)，

这就是一种**类型双关**，尽管这一次他没有给到我们想要的结果.

但是这也恰体现了C++在**内存**上的强大掌控力，

在游戏引擎架设中需要处理的**字节流**就可能需要我们用到这种对内存的操控.

