# 预编译头文件



## 为什么要用预编译头文件？

回顾编译器以及链接器原理，我们在构建项目时，我们可能会在多个头文件写下诸如`#include<vector>`的宏，该宏则多次为我们复制了各种库，然后各种库又有潜在的元引用库，导致项目的**编译时间大大加长**.

所以有了预编译头文件的出现，它使得编译器只用读所含头文件一次.

实际上预编译头文件还是**二进制文件**，这对编译器来说更好读.



## 实现

首先理清一下：

**什么应该在预编译头文件**：你无需修改的库，通常是一些外部依赖，例如`<Windows.h>` (贼大)、`STL`

**什么不应该在预编译头文件**：你可能在过程中需要不断修改的库，比如一些你自己写的库

接下来是各平台的实现👇

### Visual Studio

1 创建一个普通头文件，包含所有应该包含的需要预编译的头文件，

​	通常它叫`pch.h` (即`pre compile header`)，头文件应跟上一个同名的`.cpp`文件，

​	当然vs默认的是叫`stdafx.h`

2 右键`pch.cpp`，然后`属性 >> C/C++ >> 预处理头 >> 预编译头`，选`创建(\Yc)`

​	你可以选择更改`属性 >> C/C++ >> 预处理头 >> 预编译头文件`来更改输出预编译头文件的名字

3 右键项目 (在解决方案下)，然后`属性 >> C/C++ >> 预处理头 >> 预编译头`，选`使用(\Yu)`

​	如果你之前更改了预编译头文件的名字，此处要在下栏`属性 >> C/C++ >> 预处理头 >> 预编译头文件`填上相同	的名字.

### g++ / gdb / clang

1 选择到你的项目文件夹

2 编译你想要预编译的编译头文件 (整合后的)，itc，叫它`stdafx.h`好了

​	输入指令：`g++ -std==c++11 stdafx.h`

3 然后你会发现有一个贼大的同名`.gch`文件

4 然后照常编译其他文件就好了，现在你会发现编译快很多



**补充**

xmake 也有对 pch 的相关支持，但是实际上我们很少需要用到。

因为一般我们说 pch，都是把 **外部库** 放在 pch 里面，因为它们才是最可能**一直不变却占用大量空间的**。

但一般对于 xmake 的工作流，外部依赖都是以 **包package** 为基础的。

而包的工作原理，就是在**安装时进行源码编译**，在**被依赖时自动链接二进制文件**，**提供包含路径**。

所以并不需要 pch 哦。

如果是以 target 存在，被作为依赖的，xmake 也支持增量编译。由于其压根不会被你修改，所以不会被反复重新编译。
